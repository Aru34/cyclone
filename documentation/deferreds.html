<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Deferreds and inline callbacks &mdash; cyclone git-2013042301 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'git-2013042301',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="cyclone git-2013042301 documentation" href="index.html" />
    <link rel="next" title="Development server and production" href="devserver.html" />
    <link rel="prev" title="Overview" href="overview.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="devserver.html" title="Development server and production"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="overview.html" title="Overview"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">cyclone git-2013042301 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="deferreds-and-inline-callbacks">
<h1>Deferreds and inline callbacks<a class="headerlink" href="#deferreds-and-inline-callbacks" title="Permalink to this headline">¶</a></h1>
<p>This is one of the major differences between Cyclone and Tornado, and needs
special attention. If you&#8217;re not familiar with the subject, it is highly
recommended that you start by reading Twisted&#8217;s documentation:
<a class="reference external" href="http://twistedmatrix.com/documents/current/core/howto/defer.html">http://twistedmatrix.com/documents/current/core/howto/defer.html</a></p>
<p>Following is an example where the HTTP client <a class="reference internal" href="httpclient.html#cyclone.httpclient.fetch" title="cyclone.httpclient.fetch"><tt class="xref py py-obj docutils literal"><span class="pre">cyclone.httpclient.fetch</span></tt></a>
returns a <tt class="docutils literal"><span class="pre">Deferred</span></tt>, which is fired once the response is received:</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch

class MyRequestHandler(web.RequestHandler):
    @web.asynchronous
    def get(self):
        deferred = fetch(&quot;http://freegeoip.net/json/&quot;)
        deferred.addCallback(self.on_response)

    def on_response(self, response):
        self.write(response.body)
        self.finish()
</pre></div>
</div>
<p>Although this method seems simple, it introduces other problems. Think of
multiple queries on a database for example. Once the result set of the first
query is received, you parse it and issue a second query:</p>
<div class="highlight-none"><div class="highlight"><pre>from twisted.enterprise import adbapi

class MySQLMixin(object):
    mysql = adbapi.ConnectionPool(&quot;MySQLdb&quot;, db=&quot;dummy&quot;)

class MyRequestHandler(web.RequestHandler, MySQLMixin):
    @web.asynchronous
    def get(self):
        deferred = self.mysql.runQuery(&quot;SELECT 1&quot;)
        deferred.addCallback(self.on_response1)

    # here&#39;s where you handle the results of the 1st query
    def on_response1(self, response):
        ...
        deferred = self.mysql.runQuery(&quot;SELECT 2&quot;)
        deferred.addCallback(self.on_response2)

    # handle the results of the 2nd query and terminate the request
    def on_response2(self, response):
        ...
        self.finish()
</pre></div>
</div>
<p>Now add an HTTP client request to the mix and you&#8217;re done, it becomes a real
mess and practically unmaintainable code. Debugging is even more problematic
as your software grows in complexity.</p>
<p>On the other hand, the use of <tt class="docutils literal"><span class="pre">Deferred</span></tt> objects is a pretty decent
approach for event based programming, and plays very well with the reactor
pattern. Combined with Python generators, <tt class="docutils literal"><span class="pre">Deferreds</span></tt> can take your
application to a whole new level, as you will see in the following section.</p>
<div class="section" id="inline-callbacks">
<h2>Inline callbacks<a class="headerlink" href="#inline-callbacks" title="Permalink to this headline">¶</a></h2>
<p>Things become much easier with inline callbacks. Since generators were
introduced in Python 2.5, the implementation of <a class="reference external" href="http://en.wikipedia.org/wiki/Continuation">continuation</a> pretty much made it possible
to write sequential code that is easy to read and maintain, and use
<tt class="docutils literal"><span class="pre">Deferreds</span></tt> in a different, better way.</p>
<p>Check out the official documentation of <a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.defer.html#inlineCallbacks">twisted.internet.defer.inlineCallbacks</a>.</p>
<p>Basically, once you decorate a function with <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> it&#8217;s possible
to <tt class="docutils literal"><span class="pre">yield</span></tt> anything that returns a <tt class="docutils literal"><span class="pre">Deferred</span></tt>, and get the results
directly, without having to define a callback function.</p>
<p>Example:</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch
from twisted.internet import defer

class MyRequestHandler(web.RequestHandler):
    @defer.inlineCallbacks
    def get(self):
        response = yield fetch(&quot;http://freegeoip.net/json/&quot;)
        self.write(response.body)
        self.finish()
</pre></div>
</div>
<p>Now let&#8217;s have a second look at the MySQL example:</p>
<div class="highlight-none"><div class="highlight"><pre>from twisted.enterprise import adbapi
from twisted.web.client import getPage

class MySQLMixin(object):
    mysql = adbapi.ConnectionPool(&quot;MySQLdb&quot;, db=&quot;dummy&quot;)

class MyRequestHandler(web.RequestHandler, MySQLMixin):
    @defer.inlineCallbacks
    def get(self):
        rs1 = yield self.mysql.runQuery(&quot;SELECT 1&quot;)
        rs2 = yield self.mysql.runQuery(&quot;SELECT 2&quot;)
        xml = yield getPage(&quot;http://freegeoip.net/xml/&quot;)
</pre></div>
</div>
<p>Note that every function decorated with <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> must call <tt class="docutils literal"><span class="pre">yield</span></tt>
at least once, so they become a generator. They always return a <tt class="docutils literal"><span class="pre">Deferred</span></tt>,
and you can never call <tt class="docutils literal"><span class="pre">return</span></tt>. Instead, call <tt class="docutils literal"><span class="pre">returnValue</span></tt> to suspend
the execution and return a value (keep in mind that this is a <tt class="docutils literal"><span class="pre">Deferred</span></tt>
and you&#8217;re actually making it fire its callback with the value - it gets a
bit confusing here, but don&#8217;t worry.):</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch
from twisted.internet import defer

class MyRequestHandler(web.RequestHandler):
    @defer.inlineCallbacks
    def get_my_location(self):
        response = yield fetch(&quot;http://freegeoip.net/xml/&quot;)
        if response.code == 200:
            defer.returnValue(response.body)
        else:
            defer.returnValue(None)

    @defer.inlineCallbacks
    def get(self):
        location = yield self.get_my_location()
        if location:
            self.write(location)
        else:
            self.write(&quot;No idea where you are.&quot;)
</pre></div>
</div>
</div>
<div class="section" id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>One of the most common mistakes is to <tt class="docutils literal"><span class="pre">yield</span></tt> things without decorating the
handler with <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt>.</p>
<p>Example:</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch
from twisted.internet import defer

class MainHandler(web.RequestHandler):
    # @inlineCallbacks missing here
    def get(self):
        response = yield fetch(&quot;http://freegeoip.net/xml/&quot;)
        ...
</pre></div>
</div>
<p>Old versions of Cyclone would not catch errors like this, and therefore no
error is detected at all. The request terminates normally, but without any
content. The <tt class="xref py py-obj docutils literal"><span class="pre">Content-Length</span></tt> HTTP header is set to zero.</p>
<p>Cyclone 1.1 and newer versions can detect when the handler returns a
generator, and automatically decorate it with <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt>. It also
dumps a warning message:</p>
<div class="highlight-none"><div class="highlight"><pre>2013-01-20 17:55:11-0500 [warning] MainHandler.get() returned a generator. Perhaps it should be decorated with @inlineCallbacks.
</pre></div>
</div>
<p>Another common mistake is to decorate the handler with <tt class="docutils literal"><span class="pre">inlineCallback</span></tt> but
never <tt class="docutils literal"><span class="pre">yield</span></tt> anything:</p>
<div class="highlight-none"><div class="highlight"><pre>@inlineCallbacks
def get(self):
    response = fetch(&quot;http://freegeoip.net/xml/&quot;)  # yield missing
    ...
</pre></div>
</div>
<p>This is captured by Twisted, and an HTTP 500 is returned along with an error
message:</p>
<div class="highlight-none"><div class="highlight"><pre>2013-01-20 16:53:03-0500 Uncaught exception
    [Failure instance: Traceback: &lt;type &#39;exceptions.TypeError&#39;&gt;: inlineCallbacks requires &lt;function get at 0x10b07c8c0&gt; to produce a generator; instead got None
    cyclone/web.py:1056:_execute
    twisted/internet/defer.py:290:addCallbacks
    twisted/internet/defer.py:551:_runCallbacks
    cyclone/web.py:1066:_execute_handler
    --- &lt;exception caught here&gt; ---
    twisted/internet/defer.py:134:maybeDeferred
    twisted/internet/defer.py:1186:unwindGenerator
    ]
2013-01-20 16:53:03-0500 [http] 500 GET / (127.0.0.1) 1.09ms
</pre></div>
</div>
<p>Last, but not least, are the errors caused by the called function - the one
that you <tt class="docutils literal"><span class="pre">yield</span></tt>. The <tt class="docutils literal"><span class="pre">Deferred</span></tt> class provides both <tt class="docutils literal"><span class="pre">.addCallback</span></tt> and
<tt class="docutils literal"><span class="pre">.addErrback</span></tt> methods to schedule your callbacks, and they get called when
things succeed or fail.</p>
<p>Example:</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch

class MyRequestHandler(web.RequestHandler):
    @web.asynchronous
    def get(self):
        deferred = fetch(&quot;http://freegeoip.next/json/&quot;)  # note: .next
        deferred.addCallback(self.on_response)
        deferred.addErrback(self.on_error)

    def on_response(self, response):
        ...

    def on_error(self, error):
        ...
</pre></div>
</div>
<p>When the handler is decorated with <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> and you <tt class="docutils literal"><span class="pre">yield</span></tt>
things, there&#8217;s no way to call <tt class="docutils literal"><span class="pre">.addErrback</span></tt>. It turns out that exceptions
are actually thrown right away, and if not catch may cause Cyclone to return
an HTTP 500.</p>
<p>This is how you handle it:</p>
<div class="highlight-none"><div class="highlight"><pre>from cyclone.httpclient import fetch
from twisted.internet import defer

class MainHandler(web.RequestHandler):
    @defer.inlineCallbacks
    def get(self):
        try:
            response = yield fetch(&quot;http://freegeoip.net/xml/&quot;)
        except Exception, e:
            raise web.HTTPError(503, str(e))  # Service Unavailable
        ...
</pre></div>
</div>
</div>
<div class="section" id="database-errors">
<h2>Database errors<a class="headerlink" href="#database-errors" title="Permalink to this headline">¶</a></h2>
<p>Going back to our MySQL example, plus what was covered on the previous section,
let&#8217;s see how to handle database errors.</p>
<p>Example:</p>
<div class="highlight-none"><div class="highlight"><pre>import MySQLdb
from twisted.enterprise import adbapi
from twisted.python import log

class MySQLMixin(object):
    mysql = adbapi.ConnectionPool(&quot;MySQLdb&quot;, db=&quot;dummy&quot;)

class MyRequestHandler(web.RequestHandler, MySQLMixin):
    @defer.inlineCallbacks
    def get(self):
        try:
            rs = yield self.mysql.runQuery(&quot;SELECT 1&quot;)
        except MySQLdb.OperationalError, e:
            log.msg(&quot;MySQL error: &quot; + str(e))
            raise web.HTTPError(503)  # Service Unavailable
        ...
</pre></div>
</div>
<p>If these exceptions are not catch, they make it to the handler and therefore
cause Cyclone to respond with HTTP 500.</p>
<p>Same goes for Redis:</p>
<div class="highlight-none"><div class="highlight"><pre>import cyclone.redis
from twisted.internet import defer
from twisted.python import log

class RedisMixin(object):
    redis = cyclone.redis.lazyConnectionPool()

class MainHandler(web.RequestHandler, RedisMixin):
    @defer.inlineCallbacks
    def get(self):
        try:
            rs = yield self.redis.get(&quot;foo&quot;)
        except cyclone.redis.RedisError, e:
            log.msg(&quot;Redis error: &quot; + str(e))
            raise web.HTTPError(503)  # Service Unavailable
</pre></div>
</div>
<p>And whenever you have multiple databases on the same handler, like making
queries on both MySQL and Redis on the same request, it&#8217;s better to handle
common errors elsewhere.</p>
<p>Like every time one of the DBs fail due to syntax errors, or because they are
temporarily disconnected, you end up with too many try/except in the code.</p>
<p>We recommend creating a decorator that always respond with HTTP 503 on DB
errors:</p>
<div class="highlight-none"><div class="highlight"><pre>import MySQLdb
import functools
import cyclone.redis
from twisted.internet import defer
from twisted.python import log
from twisted.enterprise import adbapi

def dbsafe(method):
    @defer.inlineCallbacks
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        try:
            result = yield defer.maybeDeferred(method, self, *args, **kwargs)
        except MySQLdb.OperationalError, e:
            log.msg(&quot;MySQL error: &quot; + str(e))
        except cyclone.redis.RedisError, e:
            log.msg(&quot;Redis error: &quot; + str(e))
        else:
            defer.returnValue(result)
        raise web.HTTPError(503)  # Service Unavailable
    return wrapper

class DatabaseMixin(object):
    redis = cyclone.redis.lazyConnectionPool()
    mysql = adbapi.ConnectionPool(&quot;MySQLdb&quot;, db=&quot;dummy&quot;)

class MainHandler(web.RequestHandler, DatabaseMixin):
    @dbsafe
    @defer.inlineCallbacks
    def get(self):
        rs1 = yield self.mysql.runQuery(&quot;SELECT 1&quot;)
        rs2 = yield self.redis.get(&quot;foo&quot;)
        ...
</pre></div>
</div>
<p>The same approach can be used for any other resource that may become
temporarily unavailable. This helps on making the server fault tolerant.</p>
</div>
<div class="section" id="other-decorators">
<h2>Other decorators<a class="headerlink" href="#other-decorators" title="Permalink to this headline">¶</a></h2>
<p>When chaining decorators on a handler, just declare them in the natural order
that you expect things to happen.</p>
<p>Example:</p>
<div class="highlight-none"><div class="highlight"><pre>class MainHandler(web.RequestHandler):
    @web.authenticated  # make sure the user is authenticated
    @dbsafe             # avoid DB issues from breaking things
    @web.asynchronous   # only terminate the request on self.finish()
    @inlineCallbacks    # prepare for inline calls
    def get(self):
        ...
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Deferreds and inline callbacks</a><ul>
<li><a class="reference internal" href="#inline-callbacks">Inline callbacks</a></li>
<li><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li><a class="reference internal" href="#database-errors">Database errors</a></li>
<li><a class="reference internal" href="#other-decorators">Other decorators</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="overview.html"
                        title="previous chapter">Overview</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="devserver.html"
                        title="next chapter">Development server and production</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/deferreds.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="devserver.html" title="Development server and production"
             >next</a> |</li>
        <li class="right" >
          <a href="overview.html" title="Overview"
             >previous</a> |</li>
        <li><a href="index.html">cyclone git-2013042301 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Alexandre Fiori.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>